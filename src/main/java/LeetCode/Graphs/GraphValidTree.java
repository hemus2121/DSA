package LeetCode.Graphs;

/*
Problem Description

You love reading books, and you also love reading books that you've already read (weird you).
In a day, you read a total of N times, consisting of some books. Each book is represented by an index in array A.

You write the number of each book you read in the order of reading them in the array A.

You are supposed to find the book that you've least recently read (the book you haven't read for as long as possible) out of the books you've read that day (Books in array A).
 */

public class GraphValidTree {
    // check the cycle in undirected graph

    public boolean validTree(int n, int[][] edges) {
        // return checkValidTree(n, edges);
        // }

        //Using BFS to check cycle if NO cycle is found then its valid Graph Tree
        // static boolean checkValidTree(int n, int [][] edges){

        //}
        return false;
    }
    public static void main(String[] args) {

    }
}
